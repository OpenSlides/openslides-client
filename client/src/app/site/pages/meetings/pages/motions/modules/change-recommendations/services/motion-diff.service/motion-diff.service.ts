import { Injectable } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';
import { HtmlDiff } from '@openslides/motion-diff';
import { djb2hash } from 'src/app/infrastructure/utils';
import { replaceHtmlEntities } from 'src/app/infrastructure/utils/dom-helpers';

import { DiffCache, DiffLinesInParagraph, ExtractedContent, LineRange } from '../../../../definitions';
import { ViewUnifiedChange } from '../../view-models';
import { LineNumberedString } from '../line-numbering.service';

/**
 * Functionality regarding diffing, merging and extracting line ranges.
 *
 * ## Examples
 *
 * Cleaning up a string generated by CKEditor:
 *
 * ```ts
 * this.diffService.removeDuplicateClassesInsertedByCkeditor(motion.text)
 * ```
 *
 * Extracting a range specified by line numbers from a motion text:
 *
 * ```ts
 * const lineLength = 80;
 * const lineNumberedText = this.lineNumbering.insertLineNumbers(
 *   '<p>A line</p><p>Another line</p><ul><li>A list item</li><li>Yet another item</li></ul>', lineLength
 * );
 * const extractFrom = 2;
 * const extractUntil = 3;
 * const extractedData = this.diffService.extractRangeByLineNumbers(lineNumberedText, extractFrom, extractUntil)
 * ```
 *
 * Creating a valid HTML from such a extracted text, including line numbers:
 *
 * ```ts
 * const extractedHtml = this.diffService.formatDiffWithLineNumbers(extractedData, lineLength, extractFrom);
 * ```
 *
 * Creating the diff between two html strings:
 *
 * ```ts
 * const before = '<P>Lorem ipsum dolor sit amet, sed diam voluptua. At </P>';
 * const beforeLineNumbered = this.lineNumbering.insertLineNumbers(before, 80)
 * const after = '<P>Lorem ipsum dolor sit amet, sed diam voluptua. At2</P>';
 * const diff = this.diffService.diff(before, after);
 * ```ts
 *
 * Given a (line numbered) diff string, detect the line number range with changes:
 *
 * ```ts
 * this.diffService.detectAffectedLineRange(diff);
 * ```
 *
 * Given a diff'ed string, apply all changes to receive the new version of the text:
 *
 * ```ts
 * const diffedHtml =
 *   '<p>Test <span class="delete">Test 2</span> Another test <del>Test 3</del></p><p class="delete">Test 4</p>';
 * const newVersion = this.diffService.diffHtmlToFinalText(diffedHtml);
 * ```
 *
 * Replace a line number range in a text by new text:
 *
 * ```ts
 * const lineLength = 80;
 * const lineNumberedText =
 *   this.lineNumbering.insertLineNumbers(
 *     '<p>A line</p><p>Another line</p><ul><li>A list item</li><li>Yet another item</li></ul>',
 *     lineLength
 *   );
 * const merged = this.diffService.replaceLines(lineNumberedText, '<p>Replaced paragraph</p>', 1, 1);
 * ```
 */
@Injectable({
    providedIn: `root`
})
export class MotionDiffService {
    private diffCache = new DiffCache();

    public constructor(private translate: TranslateService) {}

    /**
     * Returns the HTML snippet between two given line numbers.
     * extractRangeByLineNumbers
     * Hint:
     * - if toLine === null, then everything from fromLine to the end of the fragment is returned
     *
     * In addition to the HTML snippet, additional information is provided regarding the most specific DOM element
     * that contains the whole section specified by the line numbers (like a P-element if only one paragraph is selected
     * or the most outer DIV, if multiple sections selected).
     *
     * This additional information is meant to render the snippet correctly without producing broken HTML
     *
     * In some cases, the returned HTML tags receive additional CSS classes, providing information both for
     * rendering it and for merging it again correctly.
     * - os-split-*:        These classes are set for all HTML Tags that have been split into two by this process,
     *                      e.g. if the fromLine- or toLine-line-break was somewhere in the middle of this tag.
     *                      If a tag is split, the first one receives "os-split-after", and the second
     *                      one "os-split-before".
     * For example, for the following string <p>Line 1<br>Line 2<br>Line 3</p>:
     * - extracting line 1 to 1 results in <p class="os-split-after">Line 1</p>
     * - extracting line 2 to 2 results in <p class="os-split-after os-split-before">Line 2</p>
     * - extracting line 3 to null/3 results in <p class="os-split-before">Line 3</p>
     *
     * @param {LineNumberedString} html
     * @param {number} fromLine
     * @param {number} toLine
     * @returns {ExtractedContent}
     */
    public extractRangeByLineNumbers(
        html: LineNumberedString,
        fromLine: number,
        toLine: number | null
    ): ExtractedContent {
        if (typeof html !== `string`) {
            throw new Error(`Invalid call - extractRangeByLineNumbers expects a string as first argument`);
        }

        const cacheKey = fromLine + `-` + toLine + `-` + djb2hash(html);
        const cached = this.diffCache.get(cacheKey);

        if (cached) {
            return cached;
        }

        const extractedRange = HtmlDiff.extractRangeByLineNumbers(html, fromLine, toLine);
        this.diffCache.put(cacheKey, extractedRange);

        return extractedRange;
    }

    /**
     * Convenience method that takes the html-attribute from an extractRangeByLineNumbers()-method and
     * wraps it with the context.
     *
     * @param {ExtractedContent} diff
     */
    public formatDiff(diff: ExtractedContent): string {
        return HtmlDiff.formatDiff(diff);
    }

    /**
     * This returns the line number range in which changes (insertions, deletions) are encountered.
     * As in extractRangeByLineNumbers(), "to" refers to the line breaking element at the end, i.e. the start of the
     * following line.
     *
     * TODO: This should be possible without converting the HTML to a fragment by using a regex
     *
     * @param {string} diffHtml
     * @returns {LineRange}
     */
    public detectAffectedLineRange(diffHtml: string): LineRange | null {
        const cacheKey = djb2hash(diffHtml);
        const cached = this.diffCache.get(cacheKey);
        if (cached) {
            return cached;
        }

        const range = HtmlDiff.detectAffectedLineRange(diffHtml);
        this.diffCache.put(cacheKey, range);
        return range;
    }

    /**
     * Removes .delete-nodes and <del>-Tags (including content)
     * Removes the .insert-classes and the wrapping <ins>-Tags (while maintaining content)
     *
     * @param {string} html
     * @returns {string}
     */
    public diffHtmlToFinalText(html: string): string {
        return HtmlDiff.diffHtmlToFinalText(html);
    }

    /**
     * Given a line numbered string (`oldHtml`), this method removes the text between `fromLine` and `toLine`
     * and replaces it by the string given by `newHTML`.
     * While replacing it, it also merges HTML tags that have been split to create the `newHTML` fragment,
     * indicated by the CSS classes .os-split-before and .os-split-after.
     *
     * This is used for creating the consolidated version of motions.
     *
     * @param {string} oldHtml
     * @param {string} newHTML
     * @param {number} fromLine
     * @param {number} toLine
     */
    public replaceLines(oldHtml: string, newHTML: string, fromLine: number, toLine: number): string {
        return HtmlDiff.replaceLines(oldHtml, newHTML, fromLine, toLine);
    }

    /**
     * This function calculates the diff between two strings and tries to fix problems with the resulting HTML.
     * If lineLength and firstLineNumber is given, line numbers will be returned es well
     *
     * @param {string} htmlOld
     * @param {string} htmlNew
     * @param {number} lineLength - optional
     * @param {number} firstLineNumber - optional
     * @returns {string}
     */
    public diff(
        htmlOld: string,
        htmlNew: string,
        lineLength: number | null = null,
        firstLineNumber: number | null = null
    ): string {
        const cacheKey = lineLength + ` ` + firstLineNumber + ` ` + djb2hash(htmlOld) + djb2hash(htmlNew);
        const cached = this.diffCache.get(cacheKey);
        if (cached) {
            return cached;
        }

        const diff = HtmlDiff.diff(htmlOld, htmlNew, lineLength, firstLineNumber);
        this.diffCache.put(cacheKey, diff);

        return diff;
    }

    public readdOsSplit(diff: string, versions: string[], before = false): string {
        return HtmlDiff.readdOsSplit(diff, versions, before);
    }

    public changeHasCollissions(change: ViewUnifiedChange, changes: ViewUnifiedChange[]): boolean {
        return HtmlDiff.changeHasCollissions(
            this.convertViewUnifiedChange(change),
            this.convertViewUnifiedChanges(changes)
        );
    }

    public sortChangeRequests(changes: ViewUnifiedChange[]): ViewUnifiedChange[] {
        return changes.sort((change1, change2): number => {
            if (change1.getIdentifier() === change2.getIdentifier()) {
                return change1.getIdentifier() < change2.getIdentifier() ? -1 : 1;
            }
            return change1.getLineFrom() - change2.getLineFrom();
        });
    }

    /**
     * Applies all given changes to the motion and returns the (line-numbered) text
     *
     * @param {string} motionHtml
     * @param {ViewUnifiedChange[]} changes
     * @param {number} lineLength
     * @param {boolean} showAllCollisions
     * @param {number} highlightLine
     * @param {number} firstLine
     */
    public getTextWithChanges(
        motionHtml: string,
        changes: ViewUnifiedChange[],
        lineLength: number,
        showAllCollisions: boolean,
        highlightLine?: number,
        firstLine = 1
    ): string {
        return HtmlDiff.getTextWithChanges(
            motionHtml,
            this.convertViewUnifiedChanges(changes),
            lineLength,
            showAllCollisions,
            highlightLine,
            firstLine
        );
    }

    public formatOsCollidingChanges(
        html: string,
        formatter: (el: HTMLDivElement, type: string, identifier: string, title: string, changeId: string) => void
    ): string {
        const frag = HtmlDiff.htmlToFragment(html);

        frag.querySelectorAll(`.os-colliding-change`).forEach((el: HTMLElement): void => {
            formatter.bind(this)(el as HTMLDivElement);
        });

        return HtmlDiff.fragmentToHtml(frag);
    }

    public formatOsCollidingChanges_wysiwyg_cb(el: HTMLDivElement): void {
        // This callback will only do anything the first time it's called on a generated document.
        // After that, the document should stay as it is. Hence, we remove the ol-colliding-change class
        // from the holder element to the comment.
        if (el.classList.contains(`os-colliding-change-comment`)) {
            return;
        }
        const type = el.getAttribute(`data-change-type`) ?? ``;
        const identifier = el.getAttribute(`data-identifier`) ?? ``;
        const lineFrom = el.getAttribute(`data-line-from`) ?? ``;
        const lineTo = el.getAttribute(`data-line-to`) ?? ``;

        // true if either it's a DIV with the class, or a P with a child-SPAN with the class
        const nodeIsColliding = (node: ChildNode): boolean => {
            if (!node || !node.nodeName) {
                return false;
            }
            if (node.nodeName === `DIV` && (node as HTMLDivElement).classList.contains(`os-colliding-change-holder`)) {
                return true;
            }
            if (node.nodeName === `P`) {
                for (let i = 0; i < node.childNodes.length; i++) {
                    const child = node.childNodes.item(i);
                    if (
                        child &&
                        child.nodeName === `SPAN` &&
                        (child as HTMLSpanElement).classList.contains(`os-colliding-change-holder`)
                    ) {
                        return true;
                    }
                }
            }
            return false;
        };

        const prevIsColliding = nodeIsColliding(el.previousSibling);
        const nextIsColliding = nodeIsColliding(el.nextSibling);

        // Once we start editing, the holder element should not hold the class deciding if to show a warning anymore.
        // The reason is that it might be hard to get rid of it while editing, yet we still want to be able to get rid
        // of the collision warning sign if the collision has been resolved
        el.classList.remove(`os-colliding-change`);

        // In a P, we want to have the collision markers inserted within the P's margins
        let toInsertElement: HTMLElement, commentsInInlineElement: boolean;
        if (el.children.length === 1 && el.firstChild.nodeName === `P`) {
            toInsertElement = el.firstChild as HTMLElement;
            commentsInInlineElement = true;
        } else {
            toInsertElement = el;
            commentsInInlineElement = false;
        }

        // Change recommendations do not have a title
        let strTitle: string;
        if (type === `recommendation`) {
            strTitle = this.translate.instant(`Change recommendation`);
        } else {
            strTitle = identifier;
        }
        if (parseInt(lineTo, 10) === parseInt(lineFrom, 10)) {
            strTitle += ` (` + this.translate.instant(`Line`) + ` ` + lineFrom + `)`;
        } else {
            strTitle += ` (` + this.translate.instant(`Line`) + ` ` + lineFrom + ` - ` + lineTo + `)`;
        }

        const comment = el.ownerDocument.createElement(commentsInInlineElement ? `span` : `div`);
        comment.classList.add(`os-colliding-change`);
        comment.classList.add(`os-colliding-change-comment`);
        comment.innerHTML = `&lt;` + replaceHtmlEntities(`!-- ### ` + strTitle + ` ### --`) + `&gt;`;
        if (commentsInInlineElement) {
            comment.innerHTML = comment.innerHTML + `<br>`;
        }
        if (!prevIsColliding) {
            comment.innerHTML = `==============<br>` + comment.innerHTML;
        }
        if (toInsertElement.firstChild) {
            toInsertElement.insertBefore(comment, toInsertElement.firstChild);
        } else {
            toInsertElement.appendChild(comment);
        }

        if (!nextIsColliding) {
            const terminatorComment = el.ownerDocument.createElement(commentsInInlineElement ? `span` : `div`);
            terminatorComment.innerHTML = `==============`;
            el.appendChild(terminatorComment);
        }
    }

    /**
     * This is used to extract affected lines of a paragraph with the possibility to show the context (lines before
     * and after) the changed lines and displaying the line numbers.
     *
     * @param {number} paragraphNo The paragraph number
     * @param {string} origText The original text - needs to be line-numbered
     * @param {string} newText The changed text
     * @param {number} lineLength the line length
     * @param {ViewUnifiedChange[]} changeRecos
     * @return {DiffLinesInParagraph|null}
     */
    public getAmendmentParagraphsLines(
        paragraphNo: number,
        origText: string,
        newText: string,
        lineLength: number,
        changeRecos?: ViewUnifiedChange[]
    ): DiffLinesInParagraph | null {
        const changes = this.convertViewUnifiedChanges(changeRecos || []);
        return HtmlDiff.getAmendmentParagraphsLines(paragraphNo, origText, newText, lineLength, changes);
    }

    /**
     * Returns the HTML with the changes, optionally with a highlighted line.
     * The original motion needs to be provided.
     *
     * @param {LineNumberedString} html
     * @param {ViewUnifiedChange} change
     * @param {number} lineLength
     * @param {number} highlight
     * @returns {string}
     */
    public getChangeDiff(
        html: LineNumberedString,
        change: ViewUnifiedChange,
        lineLength: number,
        highlight?: number
    ): string {
        return HtmlDiff.getChangeDiff(html, this.convertViewUnifiedChange(change), lineLength, highlight);
    }

    /**
     * Returns the remainder text of the motion after the last change
     *
     * @param {LineNumberedString} motionHtml
     * @param {ViewUnifiedChange[]} changes
     * @param {number} lineLength
     * @param {number} highlight
     * @param {LineRange} lineRange
     * @returns {string}
     */
    public getTextRemainderAfterLastChange(
        motionHtml: LineNumberedString,
        changes: ViewUnifiedChange[],
        lineLength: number,
        highlight?: number,
        lineRange?: LineRange
    ): string {
        return HtmlDiff.getTextRemainderAfterLastChange(
            motionHtml,
            this.convertViewUnifiedChanges(changes),
            lineLength,
            highlight,
            lineRange
        );
    }

    /**
     * Extracts a renderable HTML string representing the given line number range of this motion text
     *
     * @param {LineNumberedString} motionText
     * @param {LineRange} lineRange
     * @param {boolean} lineNumbers - weather to add line numbers to the returned HTML string
     * @param {number} lineLength
     * @param {number|null} highlightedLine
     */
    public extractMotionLineRange(
        motionText: LineNumberedString,
        lineRange: LineRange,
        lineNumbers: boolean,
        lineLength: number,
        highlightedLine?: number
    ): string {
        return HtmlDiff.extractMotionLineRange(motionText, lineRange, lineNumbers, lineLength, highlightedLine);
    }

    private convertViewUnifiedChanges(changes: ViewUnifiedChange[]): HtmlDiff.UnifiedChange[] {
        return changes.map(c => this.convertViewUnifiedChange(c));
    }

    private convertViewUnifiedChange(change: ViewUnifiedChange): HtmlDiff.UnifiedChange {
        let title = ``;
        try {
            title = change.getTitle();
        } catch (_) {}

        let changeType: any = `unknown`;
        try {
            changeType = change.getChangeType();
        } catch (_) {}
        return {
            isTitleChange: change.isTitleChange(),
            changeId: change.getChangeId(),
            identifier: change.getIdentifier(),
            title,
            lineTo: change.getLineTo(),
            lineFrom: change.getLineFrom(),
            changeType,
            changeNewText: change.getChangeNewText()
        };
    }
}
